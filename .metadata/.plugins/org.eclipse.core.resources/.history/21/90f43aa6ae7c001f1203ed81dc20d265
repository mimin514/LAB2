/*
 * ledma.c
 *
 *  Created on: Sep 20, 2024
 *      Author: User
 */


#include "ledma.h"
//
//const int MAX_LED_MATRIX = 8;
//int index_led_matrix = 0;
//uint8_t matrix_buffer[8] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
//int count=0;
//// Function to update the LED matrix based on the index
//void ledma_init(){
//	HAL_GPIO_WritePin(GPIOA,
//			ENM0_Pin|ENM1_Pin|ENM2_Pin|ENM3_Pin|ENM4_Pin|ENM5_Pin|ENM6_Pin|ENM7_Pin,
//			GPIO_PIN_SET);
//	HAL_GPIO_WritePin(GPIOB,
//				ROW0_Pin|ROW1_Pin|ROW2_Pin|ROW3_Pin|ROW4_Pin|ROW5_Pin|ROW6_Pin|ROW7_Pin,
//				GPIO_PIN_RESET);
//}
//
//void updateLEDMatrix(uint8_t *pattern) {
//    	if(count>=8) count=0;
//
//        // Set the current row (only one row active at a time)
//        HAL_GPIO_WritePin(GPIOA, (1 << count), GPIO_PIN_SET);
//
//        // Set the column data for this row
//        HAL_GPIO_WritePin(GPIOB, pattern[count], GPIO_PIN_SET);
//
//        // Small delay to allow the row to display
//        HAL_Delay(100);  // 1ms delay to simulate row scanning
//        count++;
//
//}
//void row(int num) {
//    switch (num){
//    		case 0:
//    			HAL_GPIO_WritePin(GPIOB,
//    							ROW0_Pin|ROW1_Pin|ROW2_Pin|ROW3_Pin|ROW4_Pin|ROW5_Pin|ROW6_Pin|ROW7_Pin,
//    							GPIO_PIN_RESET);
//    			HAL_GPIO_WritePin(GPIOB,ROW0_Pin,GPIO_PIN_SET);
//    			break;
//    		case 1:
//    			HAL_GPIO_WritePin(GPIOB,
//    							ROW0_Pin|ROW1_Pin|ROW2_Pin|ROW3_Pin|ROW4_Pin|ROW5_Pin|ROW6_Pin|ROW7_Pin,
//    							GPIO_PIN_RESET);
//    			HAL_GPIO_WritePin(GPIOB,ROW1_Pin,GPIO_PIN_SET);
//    			break;
//    		case 2:
//    			HAL_GPIO_WritePin(GPIOB,
//    							ROW0_Pin|ROW1_Pin|ROW2_Pin|ROW3_Pin|ROW4_Pin|ROW5_Pin|ROW6_Pin|ROW7_Pin,
//    							GPIO_PIN_RESET);
//    			HAL_GPIO_WritePin(GPIOB,ROW2_Pin,GPIO_PIN_SET);
//    			break;
//    		case 3:
//    			HAL_GPIO_WritePin(GPIOB,
//    							ROW0_Pin|ROW1_Pin|ROW2_Pin|ROW3_Pin|ROW4_Pin|ROW5_Pin|ROW6_Pin|ROW7_Pin,
//    							GPIO_PIN_RESET);
//    			HAL_GPIO_WritePin(GPIOB,ROW3_Pin,GPIO_PIN_SET);
//    			break;
//    		case 4:
//    			HAL_GPIO_WritePin(GPIOB,
//    							ROW0_Pin|ROW1_Pin|ROW2_Pin|ROW3_Pin|ROW4_Pin|ROW5_Pin|ROW6_Pin|ROW7_Pin,
//    							GPIO_PIN_RESET);
//    			HAL_GPIO_WritePin(GPIOB,ROW4_Pin,GPIO_PIN_SET);
//    			break;
//    		case 5:
//    			HAL_GPIO_WritePin(GPIOB,
//    							ROW0_Pin|ROW1_Pin|ROW2_Pin|ROW3_Pin|ROW4_Pin|ROW5_Pin|ROW6_Pin|ROW7_Pin,
//    							GPIO_PIN_RESET);
//    			HAL_GPIO_WritePin(GPIOB,ROW5_Pin,GPIO_PIN_SET);
//    			break;
//    		case 6:
//    			HAL_GPIO_WritePin(GPIOB,
//    							ROW0_Pin|ROW1_Pin|ROW2_Pin|ROW3_Pin|ROW4_Pin|ROW5_Pin|ROW6_Pin|ROW7_Pin,
//    							GPIO_PIN_RESET);
//    			HAL_GPIO_WritePin(GPIOB,ROW6_Pin,GPIO_PIN_SET);
//    			break;
//    		case 7:
//    			HAL_GPIO_WritePin(GPIOB,
//    							ROW0_Pin|ROW1_Pin|ROW2_Pin|ROW3_Pin|ROW4_Pin|ROW5_Pin|ROW6_Pin|ROW7_Pin,
//    							GPIO_PIN_RESET);
//    			HAL_GPIO_WritePin(GPIOB,ROW7_Pin,GPIO_PIN_SET);
//    			break;
//    		default:
//    			break;
//    	}
//}
//
//void col(int num) {
//	switch (num){
//	    		case 0:HAL_GPIO_WritePin(GPIOA,ENM0_Pin,GPIO_PIN_RESET);
//	    			break;
//	    		case 1:HAL_GPIO_WritePin(GPIOA,ENM0_Pin,GPIO_PIN_RESET);
//	    			break;
//	    		case 2:HAL_GPIO_WritePin(GPIOA,ENM0_Pin,GPIO_PIN_RESET);
//	    			break;
//	    		case 3:HAL_GPIO_WritePin(GPIOA,ENM0_Pin,GPIO_PIN_RESET);
//	    			break;
//	    		case 4:HAL_GPIO_WritePin(GPIOA,ENM0_Pin,GPIO_PIN_RESET);
//	    			break;
//	    		case 5:HAL_GPIO_WritePin(GPIOA,ENM0_Pin,GPIO_PIN_RESET);
//	    			break;
//	    		case 6:HAL_GPIO_WritePin(GPIOA,ENM0_Pin,GPIO_PIN_RESET);
//	    			break;
//	    		case 7:HAL_GPIO_WritePin(GPIOA,ENM0_Pin,GPIO_PIN_RESET);
//	    			break;
//	    		default:
//	    			break;
//	    	}
//}
//int countrow=0,countcol=0;
//// Display a pattern on the LED matrix
//void DisplayPattern(uint8_t* pattern) {
//        row(countrow);
//        if (countrow>=8) countrow=0;// Select the row
//        uint8_t col_data = pattern[countrow]; // Get the column data for the current row
//
//            if (col_data & (1 << countcol)) {
//                col(countcol); // Activate the column if the bit is set
//                countcol++;
//                if(countcol>=8)countcol=0;
//        }
//        countrow++;
//        HAL_Delay(1); // Adjust the delay for your refresh rate
//}






const int MAX_LED_MATRIX = 8;
uint8_t patternA[8] = {
    0b00111100, // Row 0:   XX  XX
    0b01000010, // Row 1:  X      X
    0b01000010, // Row 2:  X      X
    0b01111110, // Row 3:   XXXX  XX
    0b01000010, // Row 4:  X      X
    0b01000010, // Row 5:  X      X
    0b01000010, // Row 6:  X      X
    0b00000000  // Row 7:   (off)
};

int currentRow = 0;

// Function to initialize the LED matrix
void ledma_init() {
    HAL_GPIO_WritePin(GPIOA,
            ENM0_Pin | ENM1_Pin | ENM2_Pin | ENM3_Pin | ENM4_Pin | ENM5_Pin | ENM6_Pin | ENM7_Pin,
            GPIO_PIN_SET);
    HAL_GPIO_WritePin(GPIOB,
                ROW0_Pin | ROW1_Pin | ROW2_Pin | ROW3_Pin | ROW4_Pin | ROW5_Pin | ROW6_Pin | ROW7_Pin,
                GPIO_PIN_RESET);
}

// Function to set the current row
void setRow(int row) {
    HAL_GPIO_WritePin(GPIOB,
                ROW0_Pin | ROW1_Pin | ROW2_Pin | ROW3_Pin | ROW4_Pin | ROW5_Pin | ROW6_Pin | ROW7_Pin,
                GPIO_PIN_RESET); // Reset all rows

    switch (row) {
        case 0: HAL_GPIO_WritePin(GPIOB, ROW0_Pin, GPIO_PIN_SET); break;
        case 1: HAL_GPIO_WritePin(GPIOB, ROW1_Pin, GPIO_PIN_SET); break;
        case 2: HAL_GPIO_WritePin(GPIOB, ROW2_Pin, GPIO_PIN_SET); break;
        case 3: HAL_GPIO_WritePin(GPIOB, ROW3_Pin, GPIO_PIN_SET); break;
        case 4: HAL_GPIO_WritePin(GPIOB, ROW4_Pin, GPIO_PIN_SET); break;
        case 5: HAL_GPIO_WritePin(GPIOB, ROW5_Pin, GPIO_PIN_SET); break;
        case 6: HAL_GPIO_WritePin(GPIOB, ROW6_Pin, GPIO_PIN_SET); break;
        case 7: HAL_GPIO_WritePin(GPIOB, ROW7_Pin, GPIO_PIN_SET); break;
        default: break;
    }
}

// Function to set the column data for the current row
void setColumn(uint8_t data) {
    HAL_GPIO_WritePin(GPIOA, ENM0_Pin | ENM1_Pin | ENM2_Pin | ENM3_Pin | ENM4_Pin | ENM5_Pin | ENM6_Pin | ENM7_Pin, GPIO_PIN_SET); // Reset all columns

    for (int col = 0; col < 8; col++) {
        if (data & (1 << col)) {
            HAL_GPIO_WritePin(GPIOA, (1 << col), GPIO_PIN_RESET); // Set the corresponding column
        }
    }
}

#define MATRIX_SIZE 8

// Buffer lưu trữ dữ liệu ma trận
uint8_t matrix_buffer[MATRIX_SIZE] = {0x00}; // Khởi tạo thành 0

// Mảng lưu trữ hình trái tim
uint8_t heart[MATRIX_SIZE] = {0x00, 0x66, 0xFF, 0xFF, 0x7E, 0x3C, 0x18, 0x00};

// Hàm cập nhật dữ liệu ma trận
void updateMatrixBuffer(uint8_t *shape) {
    for (int i = 0; i < MATRIX_SIZE; i++) {
        matrix_buffer[i] = shape[i];
    }
}

// Hàm hiển thị ma trận
void displayMatrix() {
    for (int row = 0; row < MATRIX_SIZE; row++) {
        // Chọn hàng
        // Giả định bạn có một hàm để chọn hàng, ví dụ: setRow(row);
        setRow(row);

        // Gửi dữ liệu cho từng cột
        for (int col = 0; col < MATRIX_SIZE; col++) {
            // Kiểm tra xem bit tại cột đó có được bật không
            if (matrix_buffer[row] & (1 << col)) {
                // Bật cột (giả định bạn có hàm này)
                setColumn(col, 1); // Bật
            } else {
                setColumn(col, 0); // Tắt
            }
        }
        // Thời gian để hiển thị (delay)
        HAL_Delay(1); // Điều chỉnh độ trễ nếu cần
    }
}

